---
title: "Practica 2"
output: html_document
date: "2024-06-04"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = TRUE)
```

## Lectura de datos

```{r lectura, warning = FALSE, message = FALSE}
library(readr)
library(stringr)
library(dplyr)
library(forcats)
productos <- read_csv("productos.csv")
```

```{r head}
head(productos)
```

## Preparación datos

```{r nas}
# "Nombre no disponible" como NA
productos$Nombre[productos$Nombre == "Nombre no disponible"] <- NA
# "Marca no disponible como NA
productos$Marca[productos$Marca == "Marca no disponible"] <- NA
# "Precio no disponible" como NA
productos$Precio[productos$Precio == "Precio no disponible"] <- NA
# "Unidad no disponible" como NA
productos$unidad[productos$unidad == "Unidad no disponible"] <- NA
# "Precio por unidad no disponible" como NA
productos$precio_unidad[productos$precio_unidad == "Precio por unidad no disponible"] <- NA
# "Categoría no disponible" como NA
productos$Categoria[productos$Categoria == "Categoría no disponible"] <- NA
# "Subcategoría no disponible" como NA
productos$Subcategoria[productos$Subcategoria == "Subcategoría no disponible"] <- NA
# "Subcategoría no disponible" como NA
productos$Estado[productos$Estado == "Estado no disponible"] <- NA
```

```{r}
# Preparación variables
productos <- productos %>% 
  mutate(Precio = gsub(" €", "", Precio),
         Precio = gsub(",", ".", Precio),
         Precio = as.numeric(Precio),
         unidad = ifelse(str_detect(precio_unidad, "/"), str_split(precio_unidad, "/", simplify = TRUE)[ ,2], unidad),
         precio_unidad = ifelse(str_detect(precio_unidad, "/"), str_split(precio_unidad, "/", simplify = TRUE)[,1], precio_unidad),
         precio_unidad = gsub("\\€", "", precio_unidad),
         precio_unidad = gsub(",", ".", precio_unidad),
         # Utilizamos sub() para sacar solo el primer punto que se encuentre (quitar puntos de los miles)
         precio_unidad = ifelse(str_count(precio_unidad, pattern = "\\.") > 1, sub("\\.", "", precio_unidad), precio_unidad),
         precio_unidad = str_remove_all(precio_unidad, "\\s"),
         precio_unidad = as.numeric(precio_unidad),
         Marca = as.factor(Marca),
         Supermercado = as.factor(Supermercado),
         unidad = as.factor(unidad),
         Categoria = as.factor(Categoria),
         Subcategoria = as.factor(Subcategoria),
         Estado = as.factor(Estado)
         )

# To DO 

# Unificar factores con valores diferentes en cada tienda pero que significan lo mismo.
```

```{r}
# Unificar levels de la variable unidad
productos$unidad <- fct_collapse(productos$unidad, KILO = c(" Kgr.", "1 Kg", "KILO")) %>% 
                        fct_collapse(UNIDAD = c("1 U", " Und.", "UNIDAD")) %>% 
                        fct_collapse(LITRO = c(" Litro", "1 L", "LITRO")) %>%
                        fct_collapse(METRO = c(" MTS", "1 M", "METRO")) %>% 
                        fct_collapse(`100ml` = c(" 100ml", "100 ml", "100 ML.")) %>% # Transofrmar a LITRO?
                        fct_collapse(`100g` = c(" 100GR", "100 Gr", "100 GR.")) %>% # Transdormar a KILO?
                        fct_collapse(DOCENA = c(" doce", "1 Dc", "DOCENA")) %>% # Transformar a UNIDAD?
                        fct_collapse(LAVADO = c("1 Lv", "LAVADO", "1 Do", " Dosis")) #Transformar a UNIDAD?
```


```{r summary}
summary(productos)
```

Veient el resum dels valor de cada una de els variables, es pot eliminar la variable `Fecha` ja que té tots els seus valors iguals, per tant no aportarà cap valor a l'hora de fer l'análisis. 
Per altra banda, la columna `URL` tampoc aporta cap valor analític, ja que només aporta el directori web de cada article. 

```{r select}
productos <- productos[ ,-c(5,6)]
```


```{r faltantes}
# Proporción de valores faltantes por columna
colSums(is.na(productos)) / nrow(productos)
```
Hi haurà que estudiar les variables `Marca`, `Categoría` y `Subcategoría`, ja que tenen una proporció de valors faltants elevats. 
Respecte a les altres variables es ronda un 2\% i possiblament siguin el mateixos casos. Per tant, imputarem tots els valors que no tenen un registre ni a la varaibles `Nombre`, `Precio`, `unidad` ni `precio_unidad`, ja que no aporten cap valor analític.

```{r}
# Faltantes por supermercado
table(productos$Supermercado, is.na(productos$Marca)) %>% prop.table(margin = 2)

# Faltantes por supermercado
table(productos$Supermercado, is.na(productos$Categoria)) %>% prop.table(margin = 2)

# Faltantes por supermercado
table(productos$Supermercado, is.na(productos$Subcategoria)) %>% prop.table(margin = 2)
```
Les variables `Categoria` i `Subcategoria` no tenen cap registre de quan la variable `Supermercado` pren el valor de `Consum`. És a dir, pels articles del supermercat Consum no hi ha cap Categoria ni Subcategoria registrada.
Per tant, si es vol analitzar els articles segons les seves categories o subcategories, no es podrà tenir en compte el supermercat Consum. 

En canvi a la variable `Marca`, el 85\% de les dades faltants pertanyen a al Supermercat `Dia`. 


```{r}
# Proporcion de filas con valores faltantes en Nombre, Precio, unidad, precio_unidad
sum(is.na(productos$Nombre) & is.na(productos$Precio) & is.na(productos$unidad) & is.na(productos$precio_unidad))/nrow(productos)
```

```{r}
# Eliminamos todas las filas que se han contado anteriormente
productos <- productos[!(is.na(productos$Nombre) & is.na(productos$Precio) & is.na(productos$unidad) & is.na(productos$precio_unidad)), ]
```

Poemos realizar una estimación de la categoria y subcategoria por medio de las otras filas:

```{r}
library(readr)
library(dplyr)
library(stringr)
library(stringi)


# Separar datos en dos conjuntos: uno con categorías conocidas y otro sin ellas
datos_con_categoria <- productos %>% filter(!is.na(Categoria) & !is.na(Subcategoria))
datos_sin_categoria <- productos %>% filter(is.na(Categoria) | is.na(Subcategoria))

# Función para escapar caracteres especiales en expresiones regulares
escape_regex <- function(string) {
  # Usamos stri_escape_unicode para escapar adecuadamente caracteres especiales
  escaped_string <- stri_escape_unicode(string)
  # Reemplazamos manualmente ciertos caracteres que necesitan doble escape en contextos regex
  escaped_string <- gsub("([\\[\\]\\^\\$\\.\\|\\?\\*\\+\\(\\)\\{\\}\\=!<>:\\-])", "\\\\\\1", escaped_string, perl = TRUE)
  return(escaped_string)
}

# Función para buscar coincidencias de palabras y asignar categorías
asignar_categorias <- function(nombre_producto, datos_referencia) {
  # Preparar patrón de búsqueda basado en el nombre del producto
  # Dividir el nombre en palabras, escapar caracteres especiales y crear un patrón de búsqueda flexible
  palabras <- unlist(str_split(nombre_producto, "\\s+"))
  palabras <- sapply(palabras, escape_regex, USE.NAMES = FALSE)
  patron <- paste(palabras, collapse = "|")
  
  # Buscar coincidencias en los nombres de productos con categorías conocidas
  indices <- which(str_detect(datos_referencia$Nombre, regex(patron, ignore_case = TRUE)))
  
  if (length(indices) > 0) {
    categorias_encontradas <- datos_referencia$Categoria[indices]
    subcategorias_encontradas <- datos_referencia$Subcategoria[indices]
    
    # Devolver la categoría y subcategoría más frecuentes encontradas
    categoria_final <- names(which.max(table(categorias_encontradas)))
    subcategoria_final <- names(which.max(table(subcategorias_encontradas)))
    return(c(categoria_final, subcategoria_final))
  } else {
    return(c(NA, NA))  # No se encontraron coincidencias
  }
}

# Aplicar la función a cada producto sin categoría
resultados <- lapply(datos_sin_categoria$Nombre, asignar_categorias, datos_con_categoria)
resultados <- do.call(rbind, resultados)
colnames(resultados) <- c("Categoria", "Subcategoria")

# Unir los resultados con los datos originales sin categoría
datos_sin_categoria[c("Categoria", "Subcategoria")] <- resultados

# Combinar de nuevo con los datos originales
productos_actualizados <- bind_rows(datos_con_categoria, datos_sin_categoria)


```


```{r}
# Faltantes por supermercado
table(productos_actualizados$Supermercado, is.na(productos_actualizados$Categoria)) %>% prop.table(margin = 2)

# Faltantes por supermercado
table(productos_actualizados$Supermercado, is.na(productos_actualizados$Subcategoria)) %>% prop.table(margin = 2)
```
```{r}
# Filtrar productos del supermercado 'Consum'
productos_consum <- productos %>%
  filter(Supermercado == "Consum")

# Visualizar los resultados
print(productos_consum)


# Filtrar productos del supermercado 'Consum'
productos_consum_actualizado <- productos_actualizados %>%
  filter(Supermercado == "Consum")

# Visualizar los resultados
print(productos_consum)

print(productos_consum_actualizado)
```

Manejo de Datos Extremos:
```{r}
#  'Precio' es numérico
library(ggplot2)

# Histograma de precios
ggplot(productos, aes(x = Precio)) + 
  geom_histogram(binwidth = 1, fill = "blue", color = "black") +
  theme_minimal() +
  ggtitle("Distribución de Precios")

# Boxplot de precios
ggplot(productos, aes(y = Precio)) +
  geom_boxplot(fill = "tomato", color = "black") +
  theme_minimal() +
  ggtitle("Boxplot de Precios")

# Asegurando que Precio es numérico (si aún no se ha convertido)
productos$Precio <- as.numeric(gsub(" €", "", gsub(",", ".", productos$Precio)))

# Calcular Q1, Q3 y IQR
Q1 <- quantile(productos$Precio, 0.25, na.rm = TRUE)
Q3 <- quantile(productos$Precio, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1

# Límites para outliers
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR

# Filtrar datos extremos
outliers <- productos %>%
  filter(Precio < lower_bound | Precio > upper_bound)

print(outliers)

```

